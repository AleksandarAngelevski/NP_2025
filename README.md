# Solutions to auditory exercises and laboratory exercises for the course Advanced programming year 2025/26
## src/laboratoriski
### lab1
### Problem 1
<details>Треба да се креира апликација за банка која ќе управуваа со сметките на повеќе корисниците и ќе врши трансакции помеѓу нив. Банката работи само со долари.

За потребите на ваквата апликација треба да се напишат класите Account,Transaction и Bank. Класата Account претставува една сметка на еден корисник и треба да ги чува следните податоци:

    Име на корисникот,
    единствен идентификационен број (long)
    тековното салдо на сметката (реален број).

Оваа класа исто така треба да ги имплементира и следниве методи

    Account(String name, double balance) – конструктор со параметри (id-то треба да го генерирате сами со помош на класата java.util.Random)
    getBalance():double
    getName():String
    getId():long
    setBalance(double balance)
    toString():String – враќа стринг во следниот формат, \n означува нов ред

    Name:Andrej Gajduk\n
    Balance:20.00$\n

Класата Transaction претставува трансакција (префрлување пари од една на друга сметка), од страна на банката за што честопати се наплаќа провизија. За почеток треба да се напише класата Transaction со податочни членови за идентификационите броеви на две сметки, едната од која се одземаат парите и друга на која се додаваат парите, текстуален опис и износ на трансакцијата.

За оваа класа треба да ги имплементирате методите:

    Transaction(long fromId, long toId, Stirng description, double amount) – конструктор со параметри
    getAmount():double
    getFromId():long
    getToId():long

Оваа класа треба да е immutable, а можете и да ја направите и апстрактна бидејќи не е наменета директно да се користи туку само како основна класа за изведување на други класи.

Како што споменавме претходно банката наплаќа провизија за одредени трансакции. Има два типа на провизија, фискна сума и процент. Кај фиксна сума за било која трансакција без разлика на износот на трансакцијата се наплаќа исто провизија (пример 10$). Кај процент се пресметува процент од целиот износ (процентите се зададени како цели броеви од 1-100).

За да се прави разлика меѓу различните типови на провизија, треба да напишете уште две класи кои ќе наследуваат од Transaction кои треба да ги именувате FlatAmountProvisionTransaction и FlatPercentProvisionTransaction.

Првата класа FlatAmountProvisionTransaction треба да содржи соодветен конструктор

    FlatAmountProvisionTransaction(long fromId, long toId,double amount, double flatProvision) кој го иницијализира полето за опис на "FlatAmount" и соодветен get метод
    getFlatAmount():double

Слично и класата FlatPercentProvisionTransaction треба да има соодветен конструктор

    FlatPercentProvisionTransaction (long fromId, long toId, double amount, int centsPerDolar) кој го иницијализира полето за опис на "FlatPercent" и соодветен get метод
    getPercent():int

Исто така треба да се преоптовари equals(Object o):boolean методот и за двете класи.

За крај треба да ја имплементирате класата Bank која ги чува сметките од своите корисници и дополнително врши трансакции. Класата освен сметките на своите корисници, треба да ги чува и сопственото име и вкупната сума на трансфери како и вкупната наплатена провизија од страна на банката за сите трансакции.

Класата Bank треба да ги нуди следните методи:

    Bank(String name, Account accounts[]) – конструктор со соодветните параметри (направете сопствена копија на низата од сметки)
    makeTransaction(Transaction t):boolean – врши проверка дали корисникот ги има потребните средства на сметка и дали и двете сметки на кои се однесува трансакцијата се нависитина во банката и ако и двата услови се исполнето ја извршува трансакцијата и враќа true, во спротивно враќа false
    totalTransfers():double – ја дава вкупната сума на пари кои се префрлени во сите трансакции до сега
    totalProvision():double – ја дава вкупната провизија наплатена од банката за сите извршени трансакции до сега
    toString():String - го враќа името на банката во посебна линија во формат

    Name:Banka na RM\n
    \n

    по што следат податоците за сите корисници.

Провизијата се наплаќа така што на основната сума на трансакцијата се додава вредноста не провизијата и таа сума се одзема од првата сметка (праќачот).

За сите класи да се напишат соодветни equals и hashCode методи.</details>

### Problem 2
<details>Да се дефинира интерфејс Movable што ќе ги дефинира основните својства на еден движечки објект:

    движење нагоре (void moveUp())
    движење надолу (void moveLeft())
    движење надесно (void moveRight())
    движење налево (void moveLeft())
    пристап до моменталните x,y координати на објектот (int getCurrentXPosition() и int getCurrentYPosition()).

Постојат два типа на движечки објекти: движечка точка (MovingPoint) и движечки круг (MovingCircle). Да се дефинираат овие две класи коишто го имплементираат интерфејсот Movable.

Во класата MovingPoint се чуваат информации за:

    x и y координати (цели броеви)
    xSpeed и ySpeed : степенот на поместување на движечката точка во x насока и y насока (цели броеви)

За класата да се имплементираат:

    конструктор со аргументи: MovablePoint(int x, int y, int xSpeed, int ySpeed),
    методите наведени во интерфејсот Movable
    toString метод кој дава репрезентација на објектите во следнот формат Movable point with coordinates (5,35)

Во класата MovingCircle се чуваат информации за:

    радиусот на движечкиот круг (цел број)
    центарот на движечкиот круг (објект од класата MovingPoint).

За класата да се имплементираат:

    конструктор со аргументи: MovableCircle(int radius, MovablePoint center)
    методите наведени во интерфејсот Movable
    toString метод којшто дава репрезентација на објектите во следниот формат Movable circle with center coordinates (48,21) and radius 3

Првите четири методи од Movable (moveUp, modeDown, moveRight, moveLeft) треба да фрлат исклучок од тип ObjectCanNotBeMovedException доколку придвижувањето во соодветната насока не е возможно, односно со придвижувањето се излегува од дефинираниот простор во класата MovablesCollection. При движење на објекти од тип MovableCircle се смета дека кругот излегол од просторот, доколку неговиот центар излезе од просторот. Дозволено е дел до кругот да излезе од просторот, се додека центарот е се уште во просторот. Справете се со овие исклучоци на соодветните места. Погледнете во тест примерите какви пораки треба да се печатат кога ќе се фати исклучок од овој тип и имплементирајте го истото.

Да се дефинира класа MovablesCollection во која што ќе се чуваат информации за:

    низа од движечки објекти (Movable [] movable)
    статичка променлива за максималната вредност на координатата X (минималната е предодредена на 0)
    статичка променлива за максималната вредност на координатата Y (минималната е предодредена на 0)

За класата да се имплементираат следните методи:

    конструктор MovablesCollection(int x_MAX, int y_MAX)
    void addMovableObject(Movable m) - метод за додавање на движечки објект во колекцијата од сите движечки објекти. Пред да се додади објектот, мора да се провери дали истиот е може да се вклопи во дефинираниот простор, односно истиот да не излегува од границите 0-X_MAX за x координатата и 0-Y_MAX за y координатата. Доколку станува збор за движечки круг, потребно е целиот круг да се наоѓа во наведениот интервал на вредности. Доколку движечкиот објект не може да биде вклопен во просторот, да се фрли исклучок од тип MovableObjectNotFittableException. Потребно е да се справите со исклучокот на соодветното место во main методот. Погледнете во тест примерите какви пораки треба да се печатат кога ќе се фати исклучок од овој тип и имплементирајте го истото.
    void moveObjectsFromTypeWithDirection (TYPE type, DIRECTION direction)- метод за придвижување на движечките објекти од тип type во насока direction. TYPE и DIRECTION се енумерации кои се задедени во почетниот код. Во зависност од насоката зададена во аргументот, да се повика соодветниот метод за придвижување.
    toString() - метод кој дава репрезентација на колекцијата од движечки објекти во следниот формат: Collection of movable objects with size [големина на колекцијата]: , по што во нов ред следуваат информации за сите движечки објекти во колекцијата.
</details>

### Problem 3
<details>Дадени ви се следниве класи:

Класа Doctor

    Преставува еден доктор со основните информации за него: бројот на лиценцата, неговото име, ниво на експертиза (1-10), број на пациенти
    Доколку нивото на експертиза е 10, се смета дека докторот е Chief.
    Имплементиран е toString методот кој го печати докторот во читлив формат (име, број на лиценца, специјализација, број на пациенти и доколку е со највисоко ниво на експертиза се печати и [Chief])
    При промена на нивото на експертиза, вредноста мора да се движи во рамките од 1-10 и не смее да биде помала од претходната

Класа EmergencyRoom

    репрезентира еден ургентен центар во една болница и содржи информации за: името на болницата, медицински персонал (низа од објекти Doctor), капацитет
    Имплементирани се следниве методи: treat, forEach, count, findFirst, filter, mapToLabels, mutate, conditionalMutate, countForEvaluation, evaluate

    treat(Supplier<Doctor> supplier) - додава доктор во ургентниот центар, доколку има слободно место
    forEach(Consumer<Doctor> action) - применува зададена акција (Consumer) врз секој доктор во низата (пример: печатење)
    count(Predicate<Doctor> condition) - го враќа бројот на доктори кои го исполнуваат дадениот услов
    findFirst(Predicate<Doctor> condition) - го враќа првиот доктор кој исполнува даден услов
    filter(Predicate<Student> condition - Враќа нова низа која ги содржи само докторите кои го исполнуваат условот.
    mapToLabels(Function<Student, String> mapper) - Враќа низа од текстуални описи, добиени со трансформирање на секој доктор со дадената функција.
    mutate(Consumer<Student> mutator) - Применува промена на сите доктори (на пример, зголемување на нивото на експертиза).
    conditionalMutate(Predicate<Student> condition, Consumer<Student> mutator) - Ја применува промената само на докторите кои го исполнуваат дадениот услов.
    countForEvaluation(DoctorEvaluator evaluator) - Користи DoctorEvaluator за да изброи колку доктори исполнуваат еден услов
    evaluate(DoctorEvaluator evaluator) - Враќа нова низа која ги содржи сите доктори кои исполнуваат услов поставен со DoctorEvaluator
    toString() - Враќа текстуален опис на ургентниот центар, кој ги содржи името на болницата, бројот на доктори кои моментално работат во него и списокот од истите.

Од ваша страна потребно е да:

    Креирате функциски интерфејс DoctorEvaluator кој ќе има еден метод: boolean evaluate(Doctor doctor);
    Да креирате класа HighExpertiseEvaluator кој ќе враќа TRUE само доколку докторот има ниво на експертиза поголем или еднаков на 7.
    Да ги разрешите барањата во main делот:
        Отворете Scanner и прочитајте цел број n што го означува бројот на доктори кои ќе се внесат.
        Креирајте Supplier<Student> кој чита податоци за еден доктор од конзолата (број на лиценца, име, ниво на експертиза и број на пациенти) и враќа нов објект Doctor.
        Додадете n доктори во користејќи го методот treat.
        Користете Consumer<Student> заедно со forEach за да ги испечатите сите доктори кои работат моментално во ургентниот центар.
        Искористете ги креираните функциски интерфејси за да одредите кои доктори:
            имаат повеќе од 20 пациенти
            имаат повисоко ниво на експертиза (7+)
            Комбинирајте ги двете состојби од функциските интерфејси и искористете го методот evaluate од класата EmergencyRoom за да ги прикажеш само тие доктори.
        Користете findFirst за да го пронајдите и прикажете Chief докторот во ургентниот центар.
        Користете mutate за да и го зголемите нивото на експертиза на сите доктори за 1.
        Користете conditionalMutate за да ја зголемите експертизата за 1 само на докторите со повеќе од 30 пациенти.
        Користете mapToLabels за да ги трансформирате сите доктори во текстуални описи и испечати ги.
        На крај, испечатете ги сите информации за ургентниот центар со користење на методот toString.

---</details>

### lab2
### Problem 1
<details>Довршете ги методите</details>

### Problem 2
<details>LocalDateTime</details>

### Problem 3
<details>LocalTime API</details>

### Problem 4
<details>Да се напише класа ResizableArray која ќе претставува поле (низа) со променлива должина. Класата може да чува елементи од било кој тип (треба да биде генеричка со еден параметар T) и треба да ги има дефинирано следните методи:

    ResizableArray() - креира ново празно поле
    addElement(T element) - додава нов елемент во полето (доколку нема доволно место го зголемува капацитетот на полето).
    removeElement(T element):boolean - aко постои таков елемент истиот го брише и враќа true, во спротивно враќа false, доколку има повеќе инстанци од дадениот елемент се брише само една од нив (ако има многу празно место во полето го намалува неговиот капацитет)
    contains(T element):boolean - враќа true доколку во полето постои дадениот елемент
    toArray():Object[] - ги враќа сите елементи во полето како обична низа
    isEmpty() - враќа true доколку во полето нема ниеден елемент
    count():int - го браќа бројот на елементи во полето
    elementAt(int idx):T - го враќа елементот на соодветната позиција, доколку нема таков фрла исклучок ArrayIndexOutOfBoundsException (елементите во полето се наоѓаат на позиции [0, count()])

Забелешка: за чување на елементите мора да се користи обична низа Т[] elements, не смее да се користи ArrayList<T> и истата мора да биде декларирана како private.

Дополнително, класата ResizableArray треба да има еден статички метод:

<T> void copyAll(ResizableArray<? super T> dest, ResizableArray<? extends T> src)

Овој метод треба да изврши копирање на сите елементи од src во dest (src останува непроменета, dest ги содржи сите елементи кои ги имал од порано и дополнително сите елементи кои ги има во src).

Следно треба да се напише класа IntegerArray која наследува од класата ResizableArray IntegerArray extends ResizableArray<Integer> и служи за чување на цели броеви. Оваа класа ги нуди следниве методи:

    sum():double - ја враќа сумата на сите елементи во полето
    mean():double - го дава просекот на сите елементи во полето
    countNonZero():int - го дава бројот на елементи во полето кои имаат вредност различна од нула
    distinct():IntegerArray - враќа нов објект кој во себе ги содржи истите елементи кои ги содржи this, но нема дупликат елементи
    increment(int offset):IntegerArray - враќа нов објект кој во себе ги содржи сите елемeнти кои ги содржи this, но на нив додавајќи offset
</details>

### Problem 5
<details>Треба да се развие класа Timestamp која претставува пар на објекти од кои едниот е секогаш од тип LocalDateTime, а другиот објект е од генеричкиот тип T. Класата Timestamp ги нуди следниве функционалности:

    Timestamp(LocalDateTime time, T element) - конструктор
    getTime():LocalDateTime
    getElement():T
    compareTo(Timestamp<?> t):int - споредувањето се прави само врз основа на времињата
    equals(Object o):boolean - враќа true ако се исти времињата
    toString() :String - враќа стринг репрезентација со времето (toString) и елементот во формат time element

Забелешка: двете променливи time и element мора да бидат обележани како final.

Класата Timestamp сега треба да се искористи за да се развие класа Scheduler. Оваа класа чува повеќе објекти од класата Timestamp и исто така има еден генерички параметар T кој всушност се однесува на типот на објект кој се наоѓа во Timestamp. Класата Scheduler треба да ги имплементира следниве методи:

    Scheduler() - креира нов празен распоредувач
    add(Timestamp<T> t) - додава нов објект во распоредувачот
    remove(Timestamp<T> t):boolean - го брише соодветниот елемент од распоредувачот доколку постои и враќа true, во спротивно враќа false
    next():Timestamp<T> - го враќа следниот Timestamp објект, односно тој објект чие што време е најблиску до тековното (сега) и сѐ уште НЕ е поминато
    last():Timestamp<T> - го враќа објектот кој има време најблиску до тековното (сега) и веќе E поминат
    getAll(LocalDateTime begin, LocalDateTime end):List<Timestamp<T>> - враќа листа на настани чии времиња се наоѓаат помеѓу begin и end (не вклучувајќи ги begin и end).
</details>

### Problem 6
<details>Треба да се развие класа Queuе која претставува податочна структура ред, a во позадина e имплементирана како поврзана листа. Прво треба да се напише класа за еден елемент во листата (еден јазел) Node. Kласаta Node треба да има еден генерички параметар Т кој се однесува на елементот во јазелот и една референца кон следниот јазел во листата. Поформално класата Node треба да ги нуди следниве методи:

    Node(T element, Node<T> next) - конструктор кој ги иницијализира двете променливи
    getElement():T
    getNext():Node<T>
    setNext(Node<T> next)

Користејќи ја класата Node ја пишуваме класата Queue со следниве методи:

    Queue() – креира нов празен ред
    isEmpty():boolean - враќа true, ако редот е празен (не содржи ниеден елемент)
    enqueue(T element) - го додава елементот на крајот на редот
    dequeue():T - го отстранува елементот на почеток од редот и истиот го враќа, доколку редот е празен фрла исклучок EmptyQueueException
    peek():T - го враќа елементот на почетокот од редот (не ја менува листата), доколку редот е празен фрла исклучок EmptyQueueException
    inspect():T - го враќа елементот на крајот на редот (не ја менува листата), доколку редот е празен фрла исклучок EmptyQueueException
    count():int - го враќа бројот на елементи во редот

Забелешка: Класата Queue има еден генерички параметар кој се однесува на типот не елементи кои се чуваат во редот.

Важно: Не смее да се користат готови податочни структури како ArrayList или LinkedList, за да се имплементира класата Queue.</details>

## src/auditoriski
